# -*- encoding: utf8 -*-

# region LICENSE
# ------------------------------------------------------------------------------
# The MIT License
#
#
# Copyright 2023 Jorge A. Gomes
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# ------------------------------------------------------------------------------
# endregion (license)

# region IMPORTS

import sys

from typing import Any, Sequence

# endregion (imports)
# ---------------------------------------------------------
# region EXPORTS


__all__ = [
    'TPL_WARNING',
    'TPL_LICENSE',
    'TPL_DEPENDENCIES',
    'TPL_CONSTANTS',
    'TPL_GLOBALS',
    'TPL_UTILITIES',
    'TPL_MAIN',
    'TPL_SOURCE_CLASS_1',
    'TPL_SOURCE_CLASS_2',
]

# endregion (exports)
# ---------------------------------------------------------
# region CONSTANTS & ENUMS


TPL_WARNING = """# --------------------------------------------------------------------------------
# WARNING: DO NOT MODIFY THIS FILE! OR DO MODIFY, BUT BEFORE YOU PRECEED:

# * Understand that this file was generated by a parser generator.
# * Modifications may be overwritten by the generator.
# * If you own this file, you must know what you're doing.
# * Is not bad idea to have the grammar used to generate this source, in case you mess things up

# --------------------------------------------------------------------------------
"""

TPL_LICENSE = """# --------------------------------------------------------------------------------
# MIT License
#
# Copyright (c) {year} {cr_owner}
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# --------------------------------------------------------------------------------
"""

TPL_DEPENDENCIES = """import re
import json

from argparse import ArgumentParser, Namespace, FileType
from colorama import just_fix_windows_console, Fore, Back, Style
from dataclasses import dataclass
from enum import IntEnum, auto
"""

TPL_GLOBALS = """
# the source code parsing abstraction
source = None

# stack of namespaces to use with push_scope(), pop_scope() and declare()
scope_stack = []
# verbosity level to use with push_verb(), pop_verb()
verbosity_stack = []
# helps to avoid pushing/popping scopes when testing rules
scopes_enabled = True
"""

TPL_CONSTANTS = """
class Verbosity(IntEnum):
    ERROR = 0
    WARNING = auto()
    DEBUG1 = auto()
    SUCCESS = auto()
    DEBUG2 = auto()
    INFO = auto()
    DEBUG3 = auto()
    ALL = auto()


ERROR = Verbosity.ERROR
WARNING = Verbosity.WARNING
DEBUG1 = Verbosity.DEBUG1
SUCCESS = Verbosity.SUCCESS
DEBUG2 = Verbosity.DEBUG2
INFO = Verbosity.INFO
DEBUG3 = Verbosity.DEBUG3
ALL = Verbosity.ALL

VERB_LEVELS = {
    'error': ERROR,
    'warning': WARNING,
    'debug1': DEBUG1,
    'success': SUCCESS,
    'debug2': DEBUG2,
    'info': INFO,
    'debug3': DEBUG3,
    'all': ALL
}

"""

TPL_UTILITIES = """

def snakefy(string: str) ->'str':
    lastchar = ''
    result = ''

    for char in string:
        if lastchar:
            if char.isupper():
                if lastchar.isupper() or lastchar.isdigit() or lastchar == '_':
                    result += f'{char.lower()}'
                else:
                    result += f'_{char.lower()}'
            else:
                result += char
        else:
            result += char.lower()
        lastchar = char

    return result

def is_token(*regexes):
    ""\"Returns True if source in current position matches the immediate token value, or False otherwise""\"
    global source
    for regex in regexes:
        if source.is_regex(regex):
            return True
    return False

def match_token(*regexes):
    ""\"Tries to match an immediate token 'value' and returns its node, or None otherwise""\"
    global source
    location = source.location
    for regex in regexes:
        if m := source.match_regex(regex):
            log(False, debug3=f"Matched token with regex ```{ regex }``` at line {location[1]}, {location[2]}: '{m[0]}'")
            return { 'kind': 'TOKEN', 'value': m[0], 'lc': [ location[1], location[2] ] }
    return None

def expect_token(*regexes):
    \"""Demands the source in current position to match one of the given token values and returns its node or aborts with an error.""\"
    global source
    location = source.location
    for regex in regexes:
        if m := source.expect_regex(regex):
            return { 'kind': 'TOKEN', 'value': m[0], 'lc': [ location[1], location[2] ] }
    return None

def log(localized=False, **messages):
    global source
    for level, message in messages.items():
        if level in VERB_LEVELS:
            verbosity = VERB_LEVELS.get(level)
        else:
            continue

        # print("verbosity <= source.verbosity:", verbosity <= source.verbosity)
        if verbosity <= source.verbosity:
            if verbosity is ERROR:
                source.error(message)
            elif verbosity is WARNING:
                source.warning(message)
            elif verbosity is DEBUG1:
                source.info(message, localized, True)
            elif verbosity is SUCCESS:
                source.success(message, localized)
            elif verbosity is DEBUG2:
                source.info(message, localized, True)
            elif verbosity is INFO:
                source.info(message, localized, False)
            elif verbosity is DEBUG3:
                source.info(message, localized, True)


def reduced(node, key):
    \"""Tries to reduce the node to its key""\"
    if node:
        if key in node and len(node) == 2:
            log(False, debug1=f"{node['kind']} reduced to its {key} item: ({node[key].get('kind', 'None')})")
            return node[key]
        else:
            log(False, debug1=f"{node['kind']} not reduced")
    return node

def flipped(node, item_key, key):
    \"""Tries to set the item as paret to the node""\"
    if node:
        if item := node.get(item_key):
            del node[item_key]
            item[key] = node
            log(False, debug1=f"Item {item['kind']} now contains {node['kind']}")
            return item
        else:
            log(False, debug1=f"{node['kind']} not flipped")
    log(False, debug2="No node to flip")
    return node

def node_update(node, data):
    \"""Updates the node with items in data""\"
    if node:
        if data:
            log(False, debug1=f"{node['kind']} becomes {data['kind']}")
            log(False, debug2=f"Before update keys: {', '.join(node.keys())}")
            node.update(data)
            log(False, debug2=f"After update keys: {', '.join(node.keys())}")
        else:
            source.warning("Fail to update node: data is None")
    else:
        source.warning("Fail to update node: node is None")

def node_lookup(node, member, kind):
    \"""Extracts the member item from the node""\"
    if node:
        if m := node.get(member):
            log(False, debug1=f"{node['kind']}['{member}'] extracted")
            return m
        source.error(f"{kind} node has no '{member}' item")
    source.warning(f"Fail to lookup '{member}' item: {kind} node is None")

def push_verb(verbosity_level, do_log=False):
    global verbosity_stack, source
    if verbosity_level in VERB_LEVELS:
        if do_log:
            source.info(f"VERBOSITY: {source.verbosity.name.lower()} -> {verbosity_level}", False, False)
        verbosity_stack.append(source.verbosity)
        source.verbosity = VERB_LEVELS.get(verbosity_level)

def pop_verb(do_log=False):
    global verbosity_stack, source
    if len(verbosity_stack):
        if do_log:
            source.info(f"VERBOSITY: {verbosity_stack[-1].name.lower()} <- {source.verbosity.name.lower()}", False, False)
        source.verbosity = verbosity_stack.pop()

def push_scope():
    \"""Adds namespace behavior to the current node""\"
    global scope_stack, scopes_enabled
    if scopes_enabled:
        scope_stack.append({})

def pop_scope(node, name):
    \"""Assigns the current scope to the onwer node""\"
    global scope_stack, scopes_enabled
    if scopes_enabled:
        if len(scope_stack):
            scope = scope_stack.pop()
            if node:
                node[name] = scope
        else:
            source.error("No scope to pop")

def declare(identifier_key, node, kind):
    \"""Declares a node in the current scope""\"
    global scope_stack, scopes_enabled
    if scopes_enabled:
        if len(scope_stack):
            scope = scope_stack[-1]

            if not node:
                source.warning(f"Fail to declare {kind} node: None")
                return

            if not isinstance(identifier_key, str):
                source.error("Invalid identifier_key type")

            if identifier_key not in node:
                source.warning(f"Failed to declare {kind} node: missing identifier key '{identifier_key}'")
                return

            if name := node.get(identifier_key):
                if not isinstance(name, str):
                    source.error("Invalid node identifier type")

                if name in scope:
                    source.error(f"Redeclared name in scope: {name}")

                scope[name] = node
                log(False, debug1=f"{node['kind']} declared")
                log(False, success=f"{node['kind']} declared in scope as {name}")
            else:
                source.error(f"{node['kind']} has no {identifier_key} item")
        else:
            source.error("No active scope")

"""

TPL_MAIN = """just_fix_windows_console()

parser = ArgumentParser()
parser.add_argument('source', help="The source file path", type=FileType('r', encoding='utf8'))
parser.add_argument('-o', '--out', help="The AST output file path", type=FileType('w', encoding='utf8'), required=True)
parser.add_argument('-s', '--start', help="Set starting rule to parse", type=str, required=True)
# parser.add_argument('-v', '--verbosity', help="Set the verbosity level", choices=['error', 'warning', 'debug1', 'success', 'debug2', 'info', 'debug3', 'all'], default='error')

args: Namespace = parser.parse_args()

ast = parse(args.source.name, args.out.name, args.start)

if ast:
    try:
        json.dump(ast, args.out, indent=2)
    except Exception as e:
        print(f"Failed to save ast into file: {' '.join(repr(arg) for arg in e.args)}")
else:
    print("Done without significative output")
return 0
"""

TPL_SOURCE_CLASS_1 = """

@dataclass
class Source:
    contents: str
    current: str
    filename: str
    verbosity: Verbosity = ERROR

    @property
    def location(self) ->'tuple[str, int, int, str]':
        ""\"Returns a 4-tuple containing the filename, line number, column, and line of code\"""
        consumed = len(self.contents) - len(self.current)
        consumed_lines = self.contents[0: consumed].split('\\n')
        line_num = len(consumed_lines)
        col_num = len(consumed_lines[-1]) + 1
        remaining_line = self.current.split('\\n')[0]
        line = f"  {consumed_lines[-1]}{remaining_line}"

        return self.filename, line_num, col_num, line

    @property
    def index(self) ->'int':
        ""\"Gets or sets the current string index of the grammar contents\"""
        return len(self.contents) - len(self.current)

    @index.setter
    def index(self, value: int) ->'None':
        ind = max(0, min(value, len(self.contents) - 1))
        self.current = self.contents[ind:]

    def skip(self):
        ""\"Skip over whitespace and comments\"""
        while True:"""

TPL_SOURCE_CLASS_2 = """
            break

    def expect_regex(self, regex: str, error_message: str | None = None) ->'re.Match':
        ""\"Tries to match regex and returns its match object. Prints an error otherwise.\"""
        if m := self.match_regex(regex):
            return m
        self.error(error_message or f"Expected '{regex}'")

    def match_regex(self, regex: str, skip: bool = True) ->'re.Match | None':
        ""\"Tries to match a regex, consumes it and returns its match object. Returns None otherwise.\"""
        if m := re.match(regex, self.current):
            val = m[0].replace('\\n', '\\n')
            self.current = self.current[len(m[0]):]
            if self.verbosity >= DEBUG3:
                self.info(f"Match success: {repr(regex)}", as_debug=True)
            if skip:
                self.skip()
            return m
        else:
            if self.verbosity >= DEBUG3:
                self.info(f"Match fail: {repr(regex)}", as_debug=True)
        return None

    def is_regex(self, regex: str) ->'bool':
        ""\"Returns whether a regex matches.\"""
        if re.match(regex, self.current):
            return True
        return False

    def error(self, message: str, at: int | None = None) ->'None':
        ""\"Aborts with an error message.\"""
        if at is not None:
            self.index = at
        file, lin, col, line = self.location

        header = f"{Fore.BLACK}{Back.RED}ERROR: {Style.BRIGHT}{Fore.RED}{Back.BLACK} {message}{Style.RESET_ALL}"
        location = f"{file}:{lin}:{col}{Style.RESET_ALL}"
        pointer = f"  {' ' * (col - 1)}{Fore.RED}^{Style.RESET_ALL}"

        print(f"{header}\\n{location}\\n{line}\\n{pointer}", file=sys.stderr)
        sys.exit(1)

    def warning(self, message: str) ->'None':
        ""\"Aborts with an error message.""\"
        file, lin, col, line = self.location

        header = f"{Fore.BLACK}{Back.YELLOW}WARNING: {Style.BRIGHT}{Fore.YELLOW}{Back.BLACK} {message}{Style.RESET_ALL}"
        location = f"{file}:{lin}:{col}{Style.RESET_ALL}"
        pointer = f"  {' ' * (col - 1)}{Fore.YELLOW}^{Style.RESET_ALL}"

        print(f"{header}\\n{location}\\n{line}\\n{pointer}", file=sys.stderr)

    def info(self, message: str, localized: bool = True, as_debug: bool = False) ->'None':
        ""\"Prints an information message.""\"
        file, lin, col, line = self.location

        if as_debug:
            header = f"{Fore.BLACK}{Back.WHITE}DEBUG: {Style.BRIGHT}{Fore.WHITE}{Back.BLACK} {message}{Style.RESET_ALL}"
        else:
            header = f"{Fore.BLACK}{Back.CYAN}INFO: {Style.BRIGHT}{Fore.CYAN}{Back.BLACK} {message}{Style.RESET_ALL}"
        location = f"{file}:{lin}:{col}{Style.RESET_ALL}"
        pointer = f"  {' ' * (col - 1)}{Fore.CYAN}^{Style.RESET_ALL}"

        if localized:
            print(f"{header}\\n{location}\\n{line}\\n{pointer}", file=sys.stderr)
        else:
            print(header, file=sys.stdout)

    def success(self, message: str, localized: bool = True) ->'None':
        ""\"Prints an success message.\"""
        file, lin, col, line = self.location

        header = f"{Fore.BLACK}{Back.GREEN}SUCCESS: {Style.BRIGHT}{Fore.GREEN}{Back.BLACK} {message}{Style.RESET_ALL}"
        location = f"{file}:{lin}:{col}{Style.RESET_ALL}"
        pointer = f"  {' ' * (col - 1)}{Fore.GREEN}^{Style.RESET_ALL}"

        if localized:
            print(f"{header}\\n{location}\\n{line}\\n{pointer}", file=sys.stderr)
        else:
            print(header, file=sys.stdout)

"""

# endregion (constants)
